
# タイトル
# ==========================================================================================================================

# バブルソートはその名前が表すように、泡（Bubble）が水面に上がっていくように配列の要素が動いていきます。バブルソートは次のようなアルゴリズムで数列を昇順に並び変えます。



# 入力
# ==========================================================================================================================
# 入力の最初の行に、数列の長さを表す整数 N が与えられます。２行目に、N 個の整数が空白区切りで与えられます。

# 出力
# ==========================================================================================================================
# 出力は 2 行からなります。
# １行目に整列された数列を 1 行に出力してください。数列の連続する要素は１つの空白で区切って出力してください。
# 2 行目に交換回数を出力してください。



# 制約
# ==========================================================================================================================
# 1 ≤ N ≤ 100
# 0 ≤ A の要素 ≤ 100




# 入出例
# ==========================================================================================================================
# <in>
# 5
# 5 3 2 4 1
# <out>
# 1 2 3 4 5
# 8


# <in>
# 6
# 5 2 4 6 1 3
# <out>
# 1 2 3 4 5 6
# 9


# 値の取得
# ==========================================================================================================================
# 形式 => N が A の要素数
# N
# A1 A2 … AN

# <サンプル>
# 6
# 5 2 4 6 1 3

# <コード>
n,*a=map(int,open(0).read().split())





# 基本形 ※実際に動きます。
# ==========================================================================================================================

      
            
# 解説
# ==========================================================================================================================


# 計算速度 ※実際に動きます。
# ==========================================================================================================================
N,*A=map(int, open(0).read().split())

flag = 1
sorted_index = 0
num_of_sorting = 0
while flag:
    flag = 0
    for i in range(N-1, sorted_index, -1):  # N-1から1まで降順 
        if A[i] < A[i-1]:
            temp = A[i]
            A[i] = A[i-1]
            A[i-1] = temp
            flag = 1
            num_of_sorting += 1
    sorted_index += 1

print(' '.join(map(str, A)))
print(f"{num_of_sorting}")


# メモリ
# ==========================================================================================================================

# コードサイズ ※実際に動きます。
# ==========================================================================================================================
N,*A=map(int, open(0).read().split())
C=0
for i in range(N-1):
  for j in range(N-i-1):
    if A[j]>A[j+1]:A[j:j+2]=A[j+1],A[j];C+=1
print(*A)
print(C)










# 汎用モデル : わかりやすさ優先
# ==========================================================================================================================
def main(n,l):
    flag = 1
    sorted_index = 0
    cnt = 0
    while flag:
        flag = 0
        for i in range(n-1, sorted_index, -1):  # N-1から1まで降順 
            if l[i] < l[i-1]:
                temp = l[i]
                l[i] = l[i-1]
                l[i-1] = temp
                flag = 1
                cnt += 1
        sorted_index += 1
    return l, cnt

test_id = 5
test_data = [5,3,2,4,1]


ancer_data,ancer_cnt = main(
    n = test_id,
    l = test_data
)
print("バブルソート : ", ancer_data)
print("ソート回数 : ", ancer_cnt)


# 汎用モデル : コードサイズ 速度 ; 優先
# ==========================================================================================================================

def main(n,l):
    cnt = 0
    for i in range(n-1):
        for j in range(n-i-1):
            if l[j]>l[j+1]:l[j:j+2]=l[j+1],l[j];cnt+=1
    return l,cnt
            
            
test_id = 6
test_data = [5,2,4,6,1,3]

ancer_data,ancer_cnt = main(
    n = test_id,
    l = test_data
)

print("バブルソートデータ : ",ancer_data)
print("回数 : ",ancer_cnt)