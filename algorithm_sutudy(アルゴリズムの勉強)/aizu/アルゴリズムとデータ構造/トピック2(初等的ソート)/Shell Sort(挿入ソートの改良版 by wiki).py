

# 挿入ソート
# ==========================================================================================================================

# 次のプログラムは、挿入ソートを応用して n 個の整数を含む数列 A を昇順に整列するプログラムです。

# shellSort(A, n) は、一定の間隔 g だけ離れた要素のみを対象とした挿入ソートである insertionSort(A, n, g) を、最初は大きい値から g を狭めながら繰り返します。これをシェルソートと言います。
# 
# 上の疑似コードの ? を埋めてこのプログラムを完成させてください。n と数列 A が与えられるので、疑似コード中の m、m 個の整数 Gi(i=0,1,...,m−1)、入力 Aを昇順にした列を出力するプログラムを作成してください。ただし、出力は以下の条件を満 たす必要があります。
# 
# 1 <= m <= 100
# 0 <= Gi <= n
# cnt の値は ⌈n**1.5⌉ を超えてはならない


# 参照
# ==========================================================================================================================
# https://e-words.jp/w/%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88.html#:~:text=%E3%82%B7%E3%82%A7%E3%83%AB%E3%82%BD%E3%83%BC%E3%83%88%E3%81%A8%E3%81%AF%E3%80%81%E4%B8%8E%E3%81%88,Donald%20Shell%EF%BC%89%E3%81%8C%E8%80%83%E6%A1%88%E3%81%97%E3%81%9F%E3%80%82



# 入力
# ==========================================================================================================================
# 1 行目に整数 n が与えられます。
# 続く n 行目に n 個の整数 Ai(i=0,1,...,n−1) が与えられます。


# 出力
# ==========================================================================================================================
# 1 行目に整数 m、
# 2 行目に m 個の整数 Gi(i=0,1,...,m−1) を空白区切りで出力してください。
# 3 行目に、G を用いた場合のプログラムが終了した直後の cnt　の値を出力してください。
# 続く n 行に整列した Ai(i=0,1,...,n−1) を出力してください。

# この問題では、１つの入力に対して複数の解答があります。条件を満たす出力は全て正解となります。

# 入出例
# ==========================================================================================================================
# <in>
# 5
# 5
# 1
# 4
# 3
# 2
# <out>
# 2
# 4 1
# 3
# 1
# 2
# 3
# 4
# 5

# <in>
# 3
# 3
# 2
# 1
# <out>
# 1
# 1
# 3
# 1
# 2
# 3



# 値の取得
# ==========================================================================================================================
# 変数の前に * をつけます。

# 形式
# I
# d1
# ・
# ・
# ・
# dN

# Sample
# 4
# 10
# 8
# 8
# 6

# コード
N, *L = map(int, open(0).read().split())





# 基本形 ※実際に動きます。
# ==========================================================================================================================
            
# 解説
# ==========================================================================================================================
    

# 計算速度 ※実際に動きます。
# ==========================================================================================================================
import sys

def insertion_sort(a, n, g):
    count = 0
    for i in range(g, n):
        v = a[i]
        j = i - g
        while j >= 0 and a[j] > v:
            a[j+g] = a[j]
            j = j - g
            count += 1
        a[j+g] = v
    return count

def shell_sort(a, n):
    count = 0
    G = list([int((2.25**i-1)/1.25) for i in range(17, 0, -1)])
    G = [x for x in G if x <= n]
    m = len(G)
    for g in G:
        count += insertion_sort(a, n, g)
    return m, G, count, a

n = int(input())
a = list(map(int, sys.stdin))

m, G, count, a = shell_sort(a, n)
print(len(G))
print(*G)
print(count)
print("\n".join(map(str, a)))

# メモリ
# ==========================================================================================================================

# コードサイズ ※実際に動きます。
# ==========================================================================================================================

def InsertionSort(A,n,g):
  global cnt
  for i in range(g,n):
    v=A[i]
    j=i-g
    while j>=0 and A[j]>v:
      A[j+g]=A[j]
      j=j-g
      cnt+=1
    A[j+g]=v

n = int(input())
A = [int(input()) for i in range(n)]

G=[1]
m=0
cnt=0
while m<100:
  if G[m]*3+1>n:
    break
  G.append(G[m]*3+1)
  m+=1
G.reverse()
for i in range(m+1):
  InsertionSort(A,n,G[i])
print(m+1)
print(*G)
print(cnt)
print(*A,sep="\n")







# 汎用モデル : 速度優先
# ==========================================================================================================================

def insertion_sort(n, l, g):
    cnt = 0
    for i in range(g, n):
        v = l[i]
        j = i - g
        while j >= 0 and l[j] > v:
            l[j+g] = l[j]
            j = j - g
            cnt += 1
        l[j+g] = v
    return cnt

def shell_sort(n,l):
    cnt = 0
    G = list([int((2.25**i-1)/1.25) for i in range(17, 0, -1)])
    G = [x for x in G if x <= n]
    m = len(G)
    for g in G:
        cnt += insertion_sort(
            n = n,
            l = l,
            g = g
        )
    return m, G, cnt, l

# test_id = 3
# test_data = [3,2,1]
test_id,*test_data = map(int, open(0).read().split())
m, G, ancer_cnt, l = shell_sort(
    n = test_id,
    l = test_data
)
print(len(G))
print(*G)
print(ancer_cnt)
print(*l,sep="\n")

# 汎用モデル : コードサイズ優先
# ==========================================================================================================================





