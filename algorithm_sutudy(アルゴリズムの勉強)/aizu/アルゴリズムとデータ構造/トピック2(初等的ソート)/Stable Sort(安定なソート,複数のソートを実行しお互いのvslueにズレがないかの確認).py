
# タイトル
# ==========================================================================================================================
# トランプのカードを整列しましょう。ここでは、４つの絵柄(S, H, C, D)と９つの数字(1, 2, ..., 9)から構成される計 36 枚のカードを用います。例えば、ハートの 8 は"H8"、ダイヤの 1 は"D1"と表します。

# バブルソート及び選択ソートのアルゴリズムを用いて、与えられた N 枚のカードをそれらの数字を基準に昇順に整列するプログラムを作成してください。アルゴリズムはそれぞれ以下に示す疑似コードに従うものとします。数列の要素は 0 オリジンで記述されています。

# また、各アルゴリズムについて、与えられた入力に対して安定な出力を行っているか報告してください。ここでは、同じ数字を持つカードが複数ある場合それらが入力に出現する順序で出力されることを、「安定な出力」と呼ぶことにします。（※常に安定な出力を行うソートのアルゴリズムを安定なソートアルゴリズムと言います。）


# 独自理解
# ==========================================================================================================================
# 対象としているソートしたいデータが、絵柄と数字という共有基準でソートが出来ない(アルゴリズムによってソート後の結果が変わる。)ものなので、それをソートした時に、アルゴリズム別で、ソートの結果が同一かどうかの確認


# 参照
# ==========================================================================================================================

# 入力
# ==========================================================================================================================
# 1 行目にカードの枚数 N が与えられます。 
# 2 行目に N 枚のカードが与えられます。
# 各カードは絵柄と数字のペアを表す２文字であり、隣合うカードは１つの空白で区切られています。２文字であり、隣合うカードは１つの空白で区切られています。

# 出力
# ==========================================================================================================================
# 1 行目に、バブルソートによって整列されたカードを順番に出力してください。隣合うカードは１つの空白で区切ってください。
# 2 行目に、この出力が安定か否か（Stable またはNot stable）を出力してください。
# 3 行目に、選択ソートによって整列されたカードを順番に出力してください。隣合うカードは１つの空白で区切ってください。
# 4 行目に、この出力が安定か否か（Stable またはNot stable）を出力してください。

# 制約
# ==========================================================================================================================
# 1 ≤ N ≤ 36



# 入出例
# ==========================================================================================================================
# <in>
# 5
# H4 C9 S4 D2 C3
# <out>
# D2 C3 H4 S4 C9
# Stable
# D2 C3 S4 H4 C9
# Not stable

# <in>
# 2
# S1 H1
# <out>
# S1 H1
# Stable
# S1 H1
# Stable


# 値の取得
# ==========================================================================================================================
# 形式 => N が A の要素数
# N
# A1 A2 … AN

# <サンプル>
# 6
# 5 2 4 6 1 3

# <コード>
N,*A=map(int,open(0).read().split())





# 基本形 ※実際に動きます。※実際に動きます。
# ==========================================================================================================================
            
# 解説
# ==========================================================================================================================


# 計算速度 優先 ※実際に動きます。
# ==========================================================================================================================


def Bubble_Sort(A, n):
    for i in range(n):
        for j in range(n-1,i,-1):
            if int(A[j][1]) < int(A[j-1][1]):
                A[j], A[j-1] = A[j-1], A[j]
    return A

def Selection_Sort(A,n):
    for i in range(n):
        mini = i
        for j in range(i,n): #i以上の要素において最小のAをminiに格納
            if int(A[j][1]) < int(A[mini][1]):
                mini = j
        if A[i] != A[mini]:
            A[i], A[mini] = A[mini], A[i]
    return A
    
n = int(input())
A = input().split()

B = A[:] # ミュータブル（＝変更可能）なシーケンス——要するにリスト——のコピーを取る簡潔な方法として好まれます。
A = Bubble_Sort(A,n)
print (' '.join(A))
print ("Stable")


B =Selection_Sort(B,n)
print (' '.join(B))

if A == B:
    print ("Stable")
else:
    print ("Not stable")



# メモリ ※実際に動きます。
# ==========================================================================================================================

# コードサイズ ※実際に動きます。
# ==========================================================================================================================
n=int(input())
b=input().split()
s=b[:]
for i in range(n):
    for j in range(n-1,i,-1):
        if b[j][1]<b[j-1][1]:b[j],b[j-1]=b[j-1],b[j]
    m=i
    for j in range(i,n):
        if s[m][1]>s[j][1]:m=j
    s[m],s[i]=s[i],s[m]
print(*b)
print('Stable')
print(*s)
print(['Not s','S'][b==s]+'table')


# 分かりやすさ 速度 優先 ※実際に動きます。
# ==========================================================================================================================











# 汎用モデル : コードサイズ 優先
# ==========================================================================================================================

def main(n,l):
    c_l = l[:]
    for i in range(n):
        
        # バブルソート
        for j in range(n-1,i,-1):
            if l[j][1]<l[j-1][1]:l[j],l[j-1]=l[j-1],l[j]
        m=i
        
        # 選択ソート
        for j in range(i,n):
            if c_l[m][1]>c_l[j][1]:m=j
        c_l[m],c_l[i]=c_l[i],c_l[m]
    
    return l,c_l

test_id = 5
test_data = ["H4", "C9", "S4", "D2", "C3"]

ancer_data_b,ancer_data_s = main(
    n = test_id,
    l = test_data
)

print(*ancer_data_b)
print('Stable')
print(*ancer_data_s)
print(['Not s','S'][ancer_data_b==ancer_data_s]+'table')


# 汎用モデル : 速度優先
# ==========================================================================================================================

def Bubble_Sort(n, l):
    for i in range(n):
        for j in range(n-1,i,-1):
            if int(l[j][1]) < int(l[j-1][1]):
                l[j], l[j-1] = l[j-1], l[j]
    return l

def Selection_Sort(n,l):
    for i in range(n):
        mini = i
        for j in range(i,n): #i以上の要素において最小のAをminiに格納
            if int(l[j][1]) < int(l[mini][1]):
                mini = j
        if l[i] != l[mini]:
            l[i], l[mini] = l[mini], l[i]
    return l
    

test_id = 5
test_data = ["H4", "C9", "S4", "D2", "C3"]

test_data_copy = test_data[:] # ミュータブル（＝変更可能）なシーケンス——要するにリスト——のコピーを取る簡潔な方法として好まれます。

ancer_data_b = Bubble_Sort(
    n = test_id,
    l = test_data
)
print (' '.join(ancer_data_b))
print ("ソート内容が同一")


ancer_data_s =Selection_Sort(
    n = test_id,
    l = test_data_copy
)
print (' '.join(ancer_data_s))

if ancer_data_b == ancer_data_s:
    print ("ソート内容が同一")
else:
    print ("ソート内容が異なる")
    
    
    