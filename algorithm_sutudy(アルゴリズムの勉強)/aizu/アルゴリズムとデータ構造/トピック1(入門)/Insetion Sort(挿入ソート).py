

# 挿入ソート
# ==========================================================================================================================
# 挿入ソート（Insertion Sort）は、手持ちのトランプを並び替えるときに使われる、自然で思い付きやすいアルゴリズムの１つです。
# 片手に持ったトランプを左から小さい順に並べる場合、１枚ずつカードを取り出して、
# それをその時点ですでにソートされている並びの適切な位置に挿入していくことによって、カードを並べ替えることができます。


# 入力
# ==========================================================================================================================
# 入力の最初の行に、数列の長さを表す整数 N が与えられます。2 行目に、N 個の整数が空白区切りで与えられます。


# 出力
# ==========================================================================================================================
# 出力は N 行からなります。挿入ソートの各計算ステップでの途中結果を 1 行に出力してください。配列の要素は１つの空白で区切って出力してください。最後の要素の後の空白など、余計な空白や改行を含めると Presentation Error となりますので注意してください。


# 入出例
# ==========================================================================================================================
# <in>
# 6
# 5 2 4 6 1 3
# <out>
# 5 2 4 6 1 3
# 2 5 4 6 1 3
# 2 4 5 6 1 3
# 2 4 5 6 1 3
# 1 2 4 5 6 3
# 1 2 3 4 5 6

# <in>
# 3
# 1 2 3
# <out>
# 1 2 3
# 1 2 3
# 1 2 3



# 値の取得
# ==========================================================================================================================
# 形式 => N が A の要素数
# N
# A1 A2 … AN

# <サンプル>
# 6
# 5 2 4 6 1 3

# <コード>
n,*a=map(int,open(0).read().split())





# 基本形 ※実際に動きます。
# ==========================================================================================================================

# <コード> ※実際に動きます。
def insertion_sort(nums):
    for i in range(1, len(nums)):
        tmp = nums[i]
        j = i - 1
        while (j >= 0) & (nums[j] > tmp):
            nums[j + 1] = nums[j]
            j -= 1
        nums[j + 1] = tmp
    return nums

if __name__ == "__main__":
    n,*a=map(int,open(0).read().split())
    sorted_nums = insertion_sort(nums=a)
    print(sorted_nums)
      
            
# 解説
# ==========================================================================================================================

# <解説> ※値を取得した体で実行しています。
def insertion_sort(nums):
    for i in range(1, len(nums)):
        # 1からN要素分のfor
        tmp = nums[i]
        # tmp = [1:]の各要素の値を格納
        j = i - 1
        # j = i のひとつ前のID
        while (j >= 0) & (nums[j] > tmp):
            # while Jが0以上 & num[0:]の各要素の値がtmpより多きければ。実行
            nums[j + 1] = nums[j]
            # num[J + 1]の要素の値が、nus[J](ひとつ前の要素)に置き換わっている。
            j -= 1
            # Jから要素をひとつ引く。
        nums[j + 1] = tmp
        # 最初に取得したtmpをnums[J + 1]に代入
        print(nums)
        # プロセスを目視で確認
    return nums

if __name__ == "__main__":
    list_ = [5,8,3,2,1]
    sorted_nums = insertion_sort(nums=list_)
    
    

# 計算速度 ※実際に動きます。
# ==========================================================================================================================
n = int(input())
l = [int(x) for x in input().split()]

for i in range(n):
    a = l[i]
    j = i - 1

    while j >= 0 and l[j] > a:
        l[j+1] = l[j]
        j = j - 1

    l[j+1] = a
    print(*l)


# メモリ
# ==========================================================================================================================

# コードサイズ ※実際に動きます。
# ==========================================================================================================================
n,*a=map(int,open(0).read().split())
for i in range(1,n+1):a[:i]=sorted(a[:i]);print(*a)








# 汎用モデル : 速度優先
# ==========================================================================================================================

# 1
"""
args
---
n_ : int
    対象の要素数
l_ : list
    対象のリスト

return
---
l_ : list
    ソートしたリスト
"""
def main(n, l):
    for i in range(n):
        a = l[i]
        j = i - 1
        while j >= 0 and l[j] > a:
            l[j+1] = l[j]
            j = j - 1
        l[j+1] = a
    return l

test_id = 5
test_data = [5,8,3,2,1]
ancer_data = main(
    n = test_id,
    l = test_data
)
print(ancer_data)

# 2
"""
args
---
l_ : list
    対象のリスト

return
---
l_ : list
    ソート済み

"""
def main(l):
    for i in range(1, len(l)):
        tmp = l[i]
        j = i - 1
        while (j >= 0) & (l[j] > tmp):
            l[j + 1] = l[j]
            j -= 1
        l[j + 1] = tmp
    return l

test_data = [5,8,3,2,1]
ancer_data = main(
    l = test_data
)
print(ancer_data)

# 汎用モデル : コードサイズ優先
# ==========================================================================================================================
# 1
"""
args
---
n_ : int
    対象の要素数
l_ : list
    対象のリスト

return
---
l_ : list
    ソートしたリスト
"""
def main(n,l):
    for i in range(1,n+1):l[:i]=sorted(l[:i])
    return l

test_id = 5
test_data = [5,8,3,2,1]
ancer_data = main(
    n = test_id,
    l = test_data
)
print(ancer_data)

# 2
"""
args
---
l_ : list
    対象のリスト

return
---
l_ : list
    ソートしたリスト
"""
def main(l):
    for i in range(1,len(l)+1):l[:i]=sorted(l[:i])
    return l

test_data = [5,8,3,2,1]
ancer_data = main(
    l = test_data
)
print(ancer_data)

