

1.問は何が知りたいか。
ex)free_coffee の場合
文の最後に「タダで頼みたいあなたは、何円払えば以後タダで注文できるのか計算したくなりました。」とあるので、おそらくここに最終的に知りたいことがある。
「何」がつくところが、最終的に知りたい値。


2.与えられている値に変数を当てはめる。

3.それを求めるために必要な計算式を洗い出す。
ex)free_coffee の場合

値_0 = 最初に与えられた値
値_1 = 値_0 - ((値_0 * 割引%) / 100)
値_2 = 値_1 - ((値_1 * 割引%) / 100)
値_n = 値_n - ((値_n * 割引%) / 100)
と、なり
累計する計算式(足し算)と、単発の割合(割引算)を求める計算式が必要であることが分かる。

4.必要なルーチンの洗い出し。
どこの関数で、何をするか。
ex)free_coffee の場合
{
    # 割引価格計算ルーチン : 割引価格を計算するルーチン
    # 累計ルーチン : 累計を計算するルーチン
    # 小数点以下切り捨てるルーチン : 小数点以下切り捨てるルーチン
}

5.必要となるルーチンのハードコーディングか、関数か、クラスかを決定する
# ※関数、クラスの時は、引数、戻り値を記載。
ex)free_coffee の場合
{
    割引価格計算ルーチン : 関数(再利用性が高いので。) : 引数(価格,割引割合) : return(割引後価格)
    累計 : 組み込みのsum関数があり、合計すればよいだけなので、ハードコーディング
    小数点以下切り捨てる : 組み込みのmath.floor関数があるので、ハードコーディング
}

6.UI的なアーキテクチャの作成
具体的にどのように呼び出すか。4で決めたことより、どれをどのように繋げればよいか。
ex)free_coffee の場合
１;オフラインからの値の入力
２;一時的にデータを保管するアドレスの用意(変数,リスト)
データの保管場所の用意
{
    一時的 : リストなどで、保存し、最後に累計する
        メリット
            最後に累計する旨の記述があるので、プログラム的に分かりやすい。sum(...)的な感じで記述するので、すぐに、累計のルーチンを実行するとわかる。
        デメリット
            容量を食う
    累計演算子 : += で都度足していく。
        メリット
            容量を節約できる。
        デメリット
            関数へ、ハードコーディングすることになり、4で決めた再利用性が悪くなる。
}
※今回は条件が最大数値が10000で、かつ、条件がカフェで今後予測される最大価格もそこまで大きな値になるとは考えにくいので、再利用性を選択。

３;whileで値が0になるまで実行
４;割引価格ルーチンの呼び出し
５;戻り値をメモリに保存。
６；合計する

7.各関数を具体的に決める。


